---
title: "Let's Build Together a Computer Vision Library!"
---
<head>
<style>
.centerImage {
  display: block;
  margin-left: auto;
  margin-right: 11%;
}
</style>
</head>

<div dir="rtl">
<h1>בעיית ״קיפולי התדר״ - The Spatial Aliasing Problem </h1>
<b><u>Spatial Aliasing</u></b>
- 
היא למעשה דגימה לא יעילה או מספקת של הנתונים לאורך הצירים.
<br>
<br>
נשמע לא מובן? מאמין לכם.
<br>
<br>
אנסה להסביר לכם בצורה פשוטה ומופשטת יותר, וממבט של מדען מחשב ולא מהנדס חשמל.
<br>
כאשר אנו מבצעים טרנספורמציה כלשהי באופן נאיבי על תמונה, אנו למעשה מחשבים לכל פיקסל בתמונת מקור שלנו, את מיקומו בתמונת היעד.
<br>
מכיוון שמרחב התמונה שלנו אינו רציף (אינו נע בקטע ממשי), אלא הוא מרחב בדיד (נע בין ערכים טבעיים שלמים במקרה שלנו) אז בביצוע הטרנספורמציה אנו עלולים לקבל ערכים שאינם שלמים.
<br><br>
<b><u>לדוגמה:</u></b>
הפעלת רוטציה בזווית 30 על הפיקסל
(5,3) 
תוביל אותנו אל הפיקסל
(2.83,5.09), 
אך מכיוון שהתמונה מיוצגת על ידי מטריצה שכל תא בה מיוצג על ידי ערכים טבעיים נאלץ לעגל את הערכים שקיבלנו.
<br>
כלומר בביצוע רוטציה לפיקסל
(5,3) 
בתמונת המקור שלנו 
ערכו (הצבע שלו) יעבור לפיקסל
(3,5) 
בתמונת היעד שלנו.
<br><br>
במילים אחרות, דגמנו עבור הפיקסל
(3,5)
<b> בתמונת היעד </b>
את ערכו של הפיקסל
(5,3)
<b> בתמונת המקור. </b>

<figure>
    <img src='images/sampling1.png' alt='missing' />
    <figcaption align="center"> 
    ביצוע דגימת הצבע מפיקסל
    (u,v)
    עבור הפיקסל 
    (round(x),round(y))
    כלומר עיגלנו את הערכים 
    (x,y)
    שקיבלנו מהטרנספורמציה.
    <br>
    ממש כמו בדוגמה קודם, כאשר שהערכים שקיבלנו מהטרנספורמציה לפיקסל היעד היו (2.83,5.09)
    אך עיגלנו אותם למרכז הפיקסל הקרוב שערכיו הם
    (3,5).
      </figcaption>
</figure>
<h3><b><u>אז איפה למעשה קוראת בעיית הדגימה ולמה היא אינה מספקת אותנו ואינה יעילה?</u></b></h3> 
מכיוון שבכל חישוב לכל פיקסל יש צורך לעגל את התוצאה למרכזי הפיקסלים בתמונת היעד נקבל 2 תרחישים אינם רצויים:
<ol style="font-weight: bold;">
    <li>יהיו פיקסלים בתמונת היעד שלא ניתן להם דגימה מתמונת המקור ובפועל נקבל תמונה ״מחוררת״ בה יהיה חסר צבע לחלק מהפיקסלים</li>
    <li>יהיו פיקסלים שנדגום להם פעמיים צבע מתמונת המקור ולכן ערכים ידרסו אחד את השני עבור אותם הפיקסלים</li>
</ol>
<figure>
    <img src='images/sampling.png' alt='missing' style="width: 90%; height: auto;" />
</figure>

דוגמה מוחשית לעניין ומימוש נאיבי תוכלו למצוא בתחילת
<a href="https://royamoyal.github.io/ComputerVision-ImageProcessing-Tutorial-Blog/Rotation.html"> המדריך לרוטציה של תמונות.</a>
<br>
התוצאה שקיבלנו שם:
<br>
<figure>
<img src='images/badlion.png' style="width: 70%; height: auto;"/> <br>
</figure>

<h1 align="center"><b><u> פתרון ה-Interpolation </u></b></h1>
אינטרפולציה היא שיטת ״הערכה״ בתחום האנליזה נומרית, שהרעיון המרכזי מאחוריה, היא למעשה למצוא נקודות מידע חדשות המבוססות על טווח של סט בדיד של נקודות ידועות.
<br>
<br>
 בשפה פשוטה יותר, נניח שיש לנו קבוצת נקודות ידועות על הצירים שהתקבלו ע״י פונקציה כלשהי, אך אין לנו את הפונקציה עצמה, אלא רק את הנקודות.
 למעשה באמצעות שיטת האינטרפולציה נוכל לנסות לשחזר בקירוב את הפונקציה, או לתת הערכה לנקודות אחרות שהיינו מקבלים על ידי הפונקציה ,רק על סמך הנקודות הידועות לנו.

<figure>
    <img src='images/exampleLinearInterpolation.png' alt='missing' style="width: 70%; height: auto;" class="centerImage"/>
        <figcaption> 
        שחזור הפונקציה על סמך הנקודות האדומות הידועות לנו בשימוש בשיטה הנקראת ״אינטרפולציה לינארית״
        </figcaption>
</figure>

<h3><u><b>הגדרה לאינטרפולציה בעיבוד תמונה:</b></u></h3>
בעיבוד תמונה
זוהי טכניקה להקצות ערכים לפיקסלים בתמונות על בסיס 
הפיקסלים הסמוכים למיקום הדגימה שאינו בהכרח מותאם למיקומי התמונה התקינים.
 <br>
 כלומר, ממש כמו ההסבר בתחילת העמוד כאן, אנחנו הולכים לבצע טרנספורמציה שאינה בהכרח תוביל אותנו ל״מרכז הפיקסל, ממנו אנחנו רוצים לבצע את הדגימה.
 <br>

<br>
 איך אז זה עוזר לנו בעצם לפתור את בעיית הSpatial Aliasing?
 <br>
 אנחנו למעשה הולכים לעבור פיקסל-פיקסל בתמונת היעד ולעשות את הטרנספורמציה ההופכית לטרנספורמציה המקורית שרצינו, וע״י כך למצוא את הדגימה הנכונה לאותו הפיקסל. למרות שלא ניפול במרכז פיקסל בתמונה המקורית, נחליט על ידי שיטות האינטרפולציה השונות כיצד לדגום את ערך הפיקסל שלנו על ידי המיקום שבו נפלנו בתמונה המקורית. 
 <br>
<ol>
    <li>מכיוון שאנחנו עוברים פיקסל-פיקסל בתמונת היעד שלנו, אנחנו פותרים באופן טבעי את עניין התמונה המחוררת, כי אין מצב בו פספסנו דגימה עבור פיקסל. </li>
    <li>פתרנו גם את עניין הדגימה הכפולה עבור פיקסל בתמונת היעד, מכיוון שאנחנו דוגמים עבורו פעם אחת ויחידה את הצבע מהתמונה המקורית</li>
</ol>
 <br><br>
 איך זה קורה בפועל?
 <b>
נפעל על פי האלגוריתם הבא:
</b>
 <ol>
    <li>נחשב את הטרנספורמציה ההפוכה לפעולה שאנחנו רוצים לבצע לתמונה.
        <ul>
        <li>לדוגמה: ברוטציה של תמונה, נחשב את הטרנספורמציה(או המטריצה) ההופכית למטריצת הרוטציה/סיבוב</li>
        </ul>
    </li>
    <li>נעבור על כל הפיקסלים 
        <b>בתמונת היעד </b>
        שלנו ונחשב ע״י הטרנספורמציה ההפוכה את ״מיקום״ הדגימה של הפיקסלים הרלוונטים 
        <b>מתמונת המקור שלנו</b>
        (שימו לב שזו פעולה הפוכה לגמרי לפעולה הנאיבית שעשינו קודם)
    </li>
    <li>עבור כל מיקום בתמונת המקור שקיבלנו מהטרנספורמציה ההפוכה עבור פיקסל מסויים מתמונת היעד, נבחר באחת משלוש השיטות הבאות את הפיקסלים עבור הדגימה:
        <ul>
            <li>אינטרפולציה לשכן הקרוב ביותר
            (Nearest Neighbor Interpolation)</li>
            <li>אינטרפולציה לינארית (Bi-Linear Interpolation)</li>
            <li>אינטרפולציה קובייתית (Bi-Cubic Interpolation)</li>
        </ul>
    </li>
</ol>
    




</div>